# AI Assistant Rules

## Core Behaviors

MUST Keep responses concise and conversational without exception
MUST Use casual but professional language at all times
MUST Provide only direct, actionable responses
MUST Maintain clarity and precision in all responses
MUST Support all suggestions with concrete examples
NEVER Use filler words like "certainly", "definitely", etc. under any circumstances
NEVER Include unnecessary apologies or overly formal language whatsoever
NEVER Make vague or ambiguous suggestions in any context
NEVER Leave any recommendation open to interpretation
NEVER Skip over important technical details

## Code Assistance

MUST Tag every code block with both language and filepath without exception
MUST Show complete context around all code changes
MUST Thoroughly analyze impact on all connected components
MUST Validate suggestions against existing patterns
MUST Test suggestions for compatibility

## Learned Best Practices

MUST Tag all code blocks with complete filepath and language information
MUST Provide full context for every code change
MUST Include complete file contents for new files
MUST Implement proper thread safety in audio processing
MUST Follow established error handling patterns
MUST Maintain consistent event emission patterns

## Common Pitfalls

NEVER Modify code without considering the event bus architecture
NEVER Mix synchronous and asynchronous patterns
NEVER Leave resource cleanup unhandled
NEVER Allow disconnected signal/slot connections
NEVER Break UI theme consistency
NEVER Bypass the manager registry pattern

## Response Format

MUST Use markdown formatting for all responses
MUST Include language and filepath in every code block
MUST Group all related changes together
MUST Provide relevant context for all changes
MUST Keep all explanations focused and actionable

## Error Handling

MUST Implement comprehensive error handling
MUST Account for all possible edge cases
MUST Follow established logging patterns
MUST Include proper resource cleanup
MUST Validate error recovery paths

## Project-Specific

MUST Design all changes around the event-driven architecture
MUST Adhere to the manager registry pattern without exception
MUST Ensure audio pipeline compatibility
MUST Follow UI theme specifications exactly
MUST Maintain all signal/slot connection patterns

## Environment Variables

MUST Use COMPANY_API_KEY naming convention for all API keys
MUST Assume environment variables are pre-loaded
NEVER Use dotenv or similar environment loading libraries

## Settings Files

MUST Use YAML format for all settings and configuration files
MUST Include proper YAML validation in config loading
MUST Follow established YAML structure patterns
MUST Document all YAML configuration options
MUST Maintain backwards compatibility in YAML schemas

## Documentation URLs

MUST Reference these official documentation sources:

Core Libraries:

- PyQt6: https://doc.qt.io/qtforpython-6/
- OpenAI API: https://platform.openai.com/docs
- Anthropic API: https://docs.anthropic.com/claude/
- Deepgram: https://developers.deepgram.com/docs/
- ElevenLabs: https://docs.elevenlabs.io/

Audio Processing:

- PyAudio: https://people.csail.mit.edu/hubert/pyaudio/docs/
- SoundDevice: https://python-sounddevice.readthedocs.io/
- pyttsx3: https://pyttsx3.readthedocs.io/
- pydub: https://github.com/jiaaro/pydub#documentation
- soundfile: https://pysoundfile.readthedocs.io/

Utility Libraries:

- pyautogui: https://pyautogui.readthedocs.io/
- pyperclip: https://pyperclip.readthedocs.io/
- numpy: https://numpy.org/doc/
- flask: https://flask.palletsprojects.com/
- PyYAML: https://pyyaml.org/wiki/PyYAMLDocumentation

MUST Consult relevant documentation when implementing features
MUST Keep documentation references up to date
MUST Follow each library's best practices and conventions
MUST Document any deviations from standard library patterns
NEVER Implement features without consulting official documentation

## Audio Configuration

MUST Use device default sample rate from PyAudio device info
MUST Handle sample rate validation gracefully
MUST Log sample rate detection and usage
MUST NOT Force specific sample rates without checking device capabilities

Example device sample rate detection:

```python
device_info = self._audio.get_device_info_by_index(config.device_id)
sample_rate = int(device_info["defaultSampleRate"])
```

## Audio Stream Management

- MUST Use device's default sample rate from PyAudio device info (never hardcode)
- MUST Configure buffer size as multiple of chunk size (typically 4x) to prevent overflow
- MUST Set exception_on_overflow=False in PyAudio read operations for graceful handling

Example buffer size configuration:

```python
self._buffer_size = config.chunk_size * 4
```

## Audio Stream Shutdown

MUST Follow exact shutdown sequence:

- Set stop flag first
- Process all buffered data using get_read_available()
- Stop stream only after buffer empty
- Close stream and cleanup resources
- Reset all state flags

Example proper shutdown:

```python
# First set flags
self._stop_requested = True
self._is_processing = True

# Process remaining buffer
while self._stream.is_active() and self._stream.get_read_available() > 0:
    data = self._stream.read(chunk_size, exception_on_overflow=False)
    if data:
        process_and_store_audio(data)

# Only then stop stream
self._stream.stop_stream()
self._stream.close()
```

## Audio Buffer Processing

MUST Process all buffered audio before stream closure
MUST Use consistent sample rate throughout processing
MUST Maintain audio quality during shutdown
MUST Log buffer metrics during processing
MUST Handle all exceptions during buffer processing
MUST Reset state in finally block
MUST Clean up resources on error
MUST Maintain consistent state after errors

## Audio Stream Pitfalls

NEVER Stop stream before processing remaining buffer
NEVER Discard buffered audio data during shutdown
NEVER Close stream while data is still available
NEVER Skip audio processing during shutdown
NEVER Mix buffer sizes during processing
NEVER Leave streams open after errors

## Logging Conventions

- MUST Use logging prefixes for clarity:
  - `===` for section boundaries and major state changes
  - `>>>` for important events and successful operations
  - `!!!` for errors and warnings
- MUST Include detailed audio metrics in debug logs (sample rates, buffer sizes, min/max values)
- MUST Log all transcription pipeline stages: audio capture, processing, transcription, and UI updates

## Audio Transcription Pipeline

- MUST Follow these steps for audio transcription:

  1. Use PyAudio's paFloat32 format for raw audio capture
  2. Buffer at least 2 seconds of audio before processing
  3. Normalize audio data to [-1, 1] range before resampling
  4. Resample audio to 16kHz for Whisper compatibility
  5. Maintain 0.5 second overlap between processing chunks

- MUST Handle sample rate conversion:

  - Detect source sample rate from first audio chunk
  - Always resample to 16kHz for Whisper
  - Use scipy.signal.resample for high-quality resampling

- MUST Implement proper buffer management:
  - Store raw audio chunks in list instead of bytearray
  - Calculate total samples across all chunks
  - Keep overlap from previous processing window
  - Clear buffer after processing to prevent memory growth

Example audio processing sequence:

```python
# Convert bytes to numpy array
chunk_data = np.frombuffer(chunk, dtype=np.float32)

# Normalize if needed
if np.max(np.abs(audio_data)) > 1.0:
    audio_data = audio_data / np.max(np.abs(audio_data))

# Resample to target rate
resampled = signal.resample(audio_data, target_length)
```

## Async/Await Best Practices

MUST Define WebSocket event handlers as async functions when using async queues or event buses
MUST Use iscoroutinefunction to properly handle mixed sync/async callbacks in event systems
MUST Maintain clear async boundaries between real-time audio capture and network services
MUST Handle WebSocket connection lifecycle with proper async/await patterns

## TTS Integration Patterns

MUST Follow these steps when integrating new TTS providers:

1. Create provider interface implementation
2. Add provider type to enums
3. Create dedicated UI controls
4. Add configuration options to settings
5. Register provider in application setup
6. Implement proper audio playback handling

Example TTS provider registration:

```python
# Add TTS provider
tts_config = self.config.speech.config.get("provider_name", {})
tts_provider = ProviderClass(model_name=tts_config.get("model", "default_model"))
self.registry.register_provider(TextToSpeechProvider, tts_provider)
```

## Directory Structure Standards

MUST Follow these directory conventions:

- `recordings/` - For temporary audio recordings
- `reference_audio/` - For TTS voice reference files
- `resources/audio/` - For application audio assets

MUST Create directories with proper permissions:

```python
os.makedirs(directory_path, exist_ok=True)
```

## UI Component Design

MUST Follow these UI component patterns:

1. Separate controls into logical component classes
2. Use consistent layout structures
3. Implement proper signal/slot connections
4. Handle async operations safely
5. Provide clear user feedback
6. Include proper error handling

Example component structure:

```python
class ComponentName(QWidget):
    signal_name = pyqtSignal(type)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._connect_signals()
        self._initialize_state()
```

## Configuration Management

MUST Structure YAML configs with:

- Provider-specific sections
- Clear option hierarchies
- Default values
- Directory paths
- Feature flags

Example config structure:

```yaml
module_name:
  provider: provider_name
  config:
    provider_name:
      option1: value1
      option2: value2
```

## Audio Processing Best Practices

MUST Handle audio device changes safely:

- Log device changes only when actually changing
- Maintain device state consistently
- Handle device initialization failures
- Clean up old device connections

Example device handling:

```python
def set_device(self, device_id: int) -> None:
    if device_id != self._current_device_id:
        self._current_device_id = device_id
        self._initialize_device()
```

## Component Integration Steps

1. Create the component class
2. Add necessary imports
3. Implement required interfaces
4. Add configuration options
5. Create UI controls
6. Connect signals/slots
7. Add error handling
8. Update application setup
9. Test all interactions

## Code Organization Principles

MUST Follow these organizational patterns:

1. Group related functionality into components
2. Use consistent naming conventions
3. Implement proper interface abstractions
4. Maintain clear dependency boundaries
5. Document component interactions

## Testing Considerations

MUST Test these scenarios:

1. Device changes during operation
2. Resource cleanup on errors
3. Async operation cancellation
4. UI state consistency
5. Configuration loading/saving
6. Audio processing pipeline
7. Error recovery paths

## Subprocess Execution Patterns

MUST Follow these subprocess execution rules:

1. Command String vs List:

- Use shell=True with single string for commands needing shell features
- Use command list with shell=False for direct execution
- Always quote paths and arguments when using shell=True

Example shell=True usage:

```python
cmd = f'cli_tool --input "{input_file}" --output "{output_dir}"'
process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
```

Example shell=False usage:

```python
cmd = ["cli_tool", "--input", input_file, "--output", output_dir]
process = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE)
```

2. Output Handling:

- Use text=True for string output
- Use universal_newlines=True for consistent line endings
- Always capture both stdout and stderr
- Check process.returncode before using output

Example proper output handling:

```python
process = subprocess.Popen(
    cmd,
    shell=True,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
)
stdout, stderr = process.communicate()
if process.returncode != 0:
    raise RuntimeError(f"Command failed: {stderr}")
```

3. Resource Cleanup:

- Always use process.communicate() to avoid deadlocks
- Set timeouts for long-running processes
- Clean up temp files in finally blocks
- Handle process termination gracefully

4. Common Pitfalls:

- NEVER pass unquoted strings with spaces in shell=True mode
- NEVER use shell=True with command lists
- NEVER leave processes running without cleanup
- NEVER mix bytes and text mode in output handling
- NEVER ignore stderr when checking for errors

5. Async Integration:

- Use asyncio.create_subprocess_exec for async code
- Use shell=True with subprocess.Popen for sync code
- Never mix async and sync process handling
- Always await process.communicate() in async code

Example async process:

```python
process = await asyncio.create_subprocess_exec(
    *cmd,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE
)
stdout, stderr = await process.communicate()
```

6. Error Handling:

- Check process.returncode explicitly
- Capture and log stderr output
- Include command string in error messages
- Clean up resources on errors
- Provide detailed error context

Example error handling:

```python
try:
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    stdout, stderr = process.communicate()
    if process.returncode != 0:
        raise RuntimeError(f"Command '{cmd}' failed with code {process.returncode}: {stderr}")
except Exception as e:
    print(f"Error executing command: {e}")
    raise
```

7. File Handling:

- Use Path objects for file paths
- Check file existence before and after
- Clean up temporary files
- Use proper file permissions
- Handle path quoting correctly

Example file handling:

```python
output_file = Path(output_dir) / "output.wav"
if output_file.exists():
    output_file.unlink()
# Run command
if not output_file.exists():
    raise FileNotFoundError(f"Command failed to create {output_file}")
```

8. Logging:

- Log full command string
- Log process output
- Log error conditions
- Include timing information
- Log resource cleanup

Example logging:

```python
print(f">>> Executing command: {cmd}")
start_time = time.time()
process = subprocess.Popen(...)
stdout, stderr = process.communicate()
print(f">>> Process completed in {time.time() - start_time:.2f}s")
if stdout: print(f">>> Output:\n{stdout}")
if stderr: print(f">>> Errors:\n{stderr}")
```

## Audio Transcription Best Practices

MUST Follow these audio transcription rules:

1. Audio Format Requirements:

   - Use int16 format for raw audio capture
   - Normalize float32 values to [-1, 1] range
   - Resample to 16kHz for Whisper
   - Use single channel (mono) audio
   - Log audio metrics (shape, max values) for debugging

2. Whisper Configuration:
   - Use "base.en" or "small.en" for English-only transcription
   - Set temperature=0.0 for deterministic output
   - Adjust no_speech_threshold=0.3 for better detection
   - Remove initial prompts that can bias output
   - Use beam_size=1 for faster processing

Example Whisper configuration:

```python
result = model.transcribe(
    audio_data,
    language="en",
    task="transcribe",
    fp16=False,
    temperature=0.0,
    best_of=1,
    beam_size=1,
    no_speech_threshold=0.3
)
```

3. Audio Processing Pipeline:

```python
# Convert audio frames to numpy array
audio_data = np.frombuffer(b''.join(audio_frames), dtype=np.int16)

# Convert to float32 and normalize to [-1, 1]
audio_float = audio_data.astype(np.float32) / 32768.0

# Resample to 16kHz
from scipy import signal
original_rate = 44100
target_rate = 16000
new_samples = int(len(audio_float) * target_rate / original_rate)
audio_resampled = signal.resample(audio_float, new_samples)
```

4. Debug Logging Requirements:

   - Log received audio frame count
   - Log audio data shape and max values
   - Log resampled audio metrics
   - Include transcription confidence scores
   - Report processing duration

5. Common Pitfalls:

   - NEVER skip audio normalization
   - NEVER use wrong sample rate conversion
   - NEVER process empty audio frames
   - NEVER ignore audio level metrics
   - NEVER skip proper error handling

6. Performance Optimization:

   - Use appropriate model size for task
   - Enable GPU acceleration when available
   - Implement proper audio buffering
   - Monitor memory usage
   - Cache model loading

7. Quality Checks:
   - Validate audio levels before processing
   - Check for clipping in normalized audio
   - Verify resampling quality
   - Monitor transcription confidence
   - Log failed transcription attempts
